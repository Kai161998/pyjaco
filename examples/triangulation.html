<html>
<head>
<script language="JavaScript" src="../math.js"></script>
<script language="JavaScript" src="../defs.js"></script>
<script language="JavaScript">
function is_on_the_left(c, a, b, pts_list) {
    var __dummy0__ = pts_list.__getitem__(a);
    ax = __dummy0__.__getitem__(0);
    ay = __dummy0__.__getitem__(1);
    var __dummy1__ = pts_list.__getitem__(b);
    bx = __dummy1__.__getitem__(0);
    by = __dummy1__.__getitem__(1);
    var __dummy2__ = pts_list.__getitem__(c);
    cx = __dummy2__.__getitem__(0);
    cy = __dummy2__.__getitem__(1);
    ux = float((bx)-(ax));
    uy = float((by)-(ay));
    vx = float((cx)-(ax));
    vy = float((cy)-(ay));
    return ((ux)*(vy))-((uy)*(vx)) > 0;
}
function criterion(a, b, c, pts_list) {
    var __dummy0__ = pts_list.__getitem__(a);
    ax = __dummy0__.__getitem__(0);
    ay = __dummy0__.__getitem__(1);
    var __dummy1__ = pts_list.__getitem__(b);
    bx = __dummy1__.__getitem__(0);
    by = __dummy1__.__getitem__(1);
    var __dummy2__ = pts_list.__getitem__(c);
    cx = __dummy2__.__getitem__(0);
    cy = __dummy2__.__getitem__(1);
    ux = float((ax)-(cx));
    uy = float((ay)-(cy));
    vx = float((bx)-(cx));
    vy = float((by)-(cy));
    len_u = sqrt(((ux)*(ux))+((uy)*(uy)));
    len_v = sqrt(((vx)*(vx))+((vy)*(vy)));
    return (((ux)*(vx))+((uy)*(vy)))/((len_u)*(len_v));
}
function find_third_point(a, b, pts_list, edges) {
    "\n" + "    Take a boundary edge (a,b), and in the list of points\n" + "    find a point 'c' that lies on the left of ab and maximizes\n" + "    the angle acb\n" + "    ";
    found = 0;
    minimum = Math.pow(10, 8);
    c_index = -1;
    pt_index = -1;
    var __dummy0__ = iter(pts_list);
    var __dummy1__ = false;
    while (1) {
        var c_point;
        try {
            c_point = __dummy0__.next();
        } catch (__dummy2__) {
            if (__dummy2__.__class__ == py.StopIteration) {
                __dummy1__ = true;
                break;
            } else {
                throw __dummy2__;
            }
        }
        c_index += 1;
        if ((c_index != a)&&(c_index != b)&&(is_on_the_left(c_index,a,b,pts_list))) {
            edge_intersects = (edge_intersects_edges(tuple([a, c_index]),pts_list,edges))||(edge_intersects_edges(tuple([b, c_index]),pts_list,edges));
            if (!(edge_intersects)) {
                crit = criterion(a,b,c_index,pts_list);
                if (crit < minimum) {
                    minimum = crit;
                    pt_index = c_index;
                    found = 1;
                }
            }
        }
    }
    if (found == 0) {
        throw TriangulationError("ERROR: Optimal point not found in find_third_point().");
    }
    return pt_index;
}
function lies_inside(c, bdy_edges) {
    var __dummy0__ = iter(bdy_edges);
    var __dummy1__ = false;
    while (1) {
        var edge;
        try {
            edge = __dummy0__.next();
        } catch (__dummy2__) {
            if (__dummy2__.__class__ == py.StopIteration) {
                __dummy1__ = true;
                break;
            } else {
                throw __dummy2__;
            }
        }
        var __dummy3__ = edge;
        a = __dummy3__.__getitem__(0);
        b = __dummy3__.__getitem__(1);
        if ((c == a)||(c == b)) {
            return false;
        }
    }
    return true;
}
function is_boundary_edge(a, b, bdy_edges) {
    "\n" + "    Checks whether edge (a, b) is in the list of boundary edges\n" + "    ";
    var __dummy0__ = iter(bdy_edges);
    var __dummy1__ = false;
    while (1) {
        var edge;
        try {
            edge = __dummy0__.next();
        } catch (__dummy2__) {
            if (__dummy2__.__class__ == py.StopIteration) {
                __dummy1__ = true;
                break;
            } else {
                throw __dummy2__;
            }
        }
        var __dummy3__ = edge;
        a0 = __dummy3__.__getitem__(0);
        b0 = __dummy3__.__getitem__(1);
        if ((a == a0)&&(b == b0)) {
            return true;
        }
    }
    return false;
}
function triangulate_af(pts_list, bdy_edges) {
    "\n" + "    Create a triangulation using the advancing front method.\n" + "    ";
    elems = list([]);
    while (len(bdy_edges) > 0) {
        var __dummy0__ = bdy_edges.pop();
        a = __dummy0__.__getitem__(0);
        b = __dummy0__.__getitem__(1);
        c = find_third_point(a,b,pts_list,bdy_edges);
        elems.append(tuple([a, b, c]));
        if (is_boundary_edge(c,a,bdy_edges)) {
            bdy_edges.remove(tuple([c, a]));
        } else {
            bdy_edges.append(tuple([a, c]));
        }
        if (is_boundary_edge(b,c,bdy_edges)) {
            bdy_edges.remove(tuple([b, c]));
        } else {
            bdy_edges.append(tuple([c, b]));
        }
    }
    return elems;
}
function ccw(A, B, C) {
    return ((C.__getitem__(1))-(A.__getitem__(1)))*((B.__getitem__(0))-(A.__getitem__(0))) > ((B.__getitem__(1))-(A.__getitem__(1)))*((C.__getitem__(0))-(A.__getitem__(0)));
}
function intersect(A, B, C, D) {
    return (ccw(A,C,D) != ccw(B,C,D))&&(ccw(A,B,C) != ccw(A,B,D));
}
function two_edges_intersect(nodes, e1, e2) {
    "\n" + "    Checks whether the two edges intersect.\n" + "\n" + "    It assumes that e1 and e2 are tuples of (a_id, b_id) of ids into the nodes.\n" + "    ";
    A = nodes.__getitem__(e1.__getitem__(0));
    B = nodes.__getitem__(e1.__getitem__(1));
    C = nodes.__getitem__(e2.__getitem__(0));
    D = nodes.__getitem__(e2.__getitem__(1));
    return intersect(A,B,C,D);
}
function edge_intersects_edges(e1, nodes, edges) {
    "\n" + "    Returns True if 'e1' intersects any edge from 'edges'.\n" + "    ";
    var __dummy0__ = iter(range(len(edges)));
    var __dummy1__ = false;
    while (1) {
        var i;
        try {
            i = __dummy0__.next();
        } catch (__dummy2__) {
            if (__dummy2__.__class__ == py.StopIteration) {
                __dummy1__ = true;
                break;
            } else {
                throw __dummy2__;
            }
        }
        e2 = edges.__getitem__(i);
        if ((e1.__getitem__(1) == e2.__getitem__(0))||(e1.__getitem__(0) == e2.__getitem__(1))) {
            continue;
        }
        if (two_edges_intersect(nodes,e1,e2)) {
            return true;
        }
    }
    return false;
}
function example1() {
    nodes = list([tuple([0, 0]), tuple([1, 0]), tuple([1, 1]), tuple([0.5, 1.5]), tuple([0, 1])]);
    edges = list([tuple([0, 1]), tuple([1, 2]), tuple([2, 3]), tuple([3, 4]), tuple([4, 0])]);
    s1 = str(edges);
    elems = triangulate_af(nodes,edges);
    result = ((((str(nodes))+("\n" + ""))+(s1))+("\n" + ""))+(str(elems));
    return result;
}
function start_triag() {
    js_pre = document.getElementById("js_pre");
    js_pre.textContent = "start";
    canvas = document.getElementById("canvas").getContext("2d");
    canvas.fillStyle = "rgb(0, 0, 0)";
    js_pre.textContent = "canvas";
    var __dummy0__ = tuple([10, 10]);
    x = __dummy0__.__getitem__(0);
    y = __dummy0__.__getitem__(1);
    canvas.fillRect(x,y,(x)+(10),(y)+(10));
    var __dummy1__ = tuple([0, 50]);
    x = __dummy1__.__getitem__(0);
    y = __dummy1__.__getitem__(1);
    canvas.fillText("Some example text",x,y);
    js_pre.textContent = "triag";
    s = example1();
    js_pre.textContent = "done";
    js_pre.textContent = s;
}

</script>
</head>
<body onLoad="start_triag()">
    <h1>Triangulation Demo</h1>
    Python output:<br/>
    <pre id="py_pre">[(0, 0), (1, 0), (1, 1), (0.5, 1.5), (0, 1)]
[(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]
[(4, 0, 1), (4, 1, 2), (4, 2, 3)]</pre>
    JavaScript output:<br/>
    <pre id="js_pre"></pre>
    Canvas:<br/>
    <canvas id="canvas" width="200" height="200"></canvas>
    <br/>
    End of page.
</body>
</html>
